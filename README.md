# xpath-example
XPath - примеры запросов

/ - выбрать корневой узел длкумента

/html - выбрать корневой элемент

/html/body/div - выбрать элемент div, который является прямым наследником элемента body

/html/body/div/* - выбрать все элементы, которые являются прямыми наследниками div

//li - выбрать все div элементы независимо от их позиции в документе

//li[1] - выбрать первый дочерний элемент li

//li[last()] - выбрать последний дочерний элемент li

//li[position()<3] - выбрать первый и второй дочерний элемент li в списке

(//li)[2] - выбрать второй элемент в общей структуре

//div[@name] - выбрать все div элементы, у которых есть атрибут name

//div[@name=’content’] - выбрать все div элементы у которых значение атрибута name равно content

//div[@name=’content’ or @class] - выбрать все div элементы у которых значение name равно content или если у них есть атрибут class

and - должны выполняться оба условия

or - должно выполняться хоть одно их условий

not() - инверсия значения

//div[contains(@class, ‘btn’)] - выбрать все div элементы у которых атрибут class содержит подстроку btn

//div[text()=’hello world’] - выбрать все элементы div внутри которых текст является hello world

//div[contains(., ‘world’)] - выбрать все элементы div у которых любой из вложенных элементов содержит слово world

//div[./span] - выбрать все элементы div у которых есть прямой наследник span

//div | //span - выбрать все элементы div или span

Оси
Оси — это база языка XPath. Для некоторых осей существуют сокращённые обозначения.

child:: — содержит множество элементов-потомков (элементов, расположенных на один уровень ниже). Это название сокращается полностью, то есть его можно вовсе опускать.

descendant:: — содержит полное множество элементов-потомков (то есть, как ближайших элементов-потомков, так и всех их элементов-потомков).

descendant-or-self:: — содержит полное множество элементов-потомков и текущий элемент. Выражение /descendant-or-self::node()/ можно сокращать до //. С помощью этой оси, например, можно вторым шагом организовать отбор элементов с любого узла, а не только с корневого: достаточно первым шагом взять всех потомков корневого. Например, путь //span отберёт все узлы span документа, независимо от их положения в иерархии, взглянув как на имя корневого, так и на имена всех его дочерних элементов, на всю глубину их вложенности.

ancestor:: — содержит множество элементов-предков.

ancestor-or-self:: — содержит множество элементов-предков и текущий элемент.

parent:: — содержит элемент-предок на один уровень назад. Это обращение можно заменить на ..

self:: — содержит текущий элемент. Это обращение можно заменить на .

following:: — содержит множество элементов, расположенных ниже текущего элемента по дереву (на всех уровнях и слоях), исключая собственных потомков.

following-sibling:: — содержит множество братских элементов того же уровня, следующих за текущим слоем.

preceding:: — содержит множество элементов, расположенных выше текущего элемента по дереву (на всех уровнях и слоях), исключая множество собственных предков.

preceding-sibling:: — содержит множество братских элементов того же уровня, предшествующих текущему слою.

attribute:: — содержит множество атрибутов текущего элемента. Это обращение можно заменить на символ @

namespace:: — содержит множество элементов, относящихся к тому или иному пространству имён (то есть присутствует атрибут xmlns).
